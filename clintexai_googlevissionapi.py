# -*- coding: utf-8 -*-
"""clintexai_googlevissionapi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VFisvEoYTFij7B6TFVEmrFlRdqoZkKhp
"""

# Install required libraries
!pip install --quiet opencv-python pillow scikit-image pytesseract openpyxl easyocr fuzzywuzzy python-Levenshtein reportlab Flask google-cloud-vision pandas matplotlib

import os
import re
import cv2
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
from google.cloud import vision
import io
import json
from difflib import get_close_matches
from fuzzywuzzy import process
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
import pytesseract
import easyocr
import tempfile
from rapidfuzz import process as rapidfuzz_process, fuzz

from google.colab import drive

# Mount Google Drive
drive.mount('/content/drive')

# Path configurations
DATASET_PATH = '/content/drive/MyDrive/clintex_dataset/datasetkim'  # Your image dataset
EXPANDED_DRUG_DATASET = '/content/drive/MyDrive/clintex_dataset/dataset/A_Z_medicines_dataset_of_India.csv'  # Your cleaned drug database
CREDENTIALS_PATH = '/content/drive/MyDrive/clintex_dataset/dataset/new.json'  # We'll create this file

# Write the credentials JSON to a file (you should store these more securely in production)
with open(CREDENTIALS_PATH, 'w') as f:
    credentials = {
        "type": "service_account",
        "project_id": "clintexai-459908",
        "private_key_id": "83660d75bd074f9a97aaa6df731ad0d540cb2216",
        "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC9c050DOgFsJ+a\nv5+dgNAqNCJy+NRCp6mplcp1igHVLddAt+dQZx/pZ996mNLDvsw4RzfMQIsO7B6K\n3qu/ULONuf4ndbQ9vu2BANFcPCPwSuyUHCACq7EPc7bZvatVYL+0A6Ph8sBIGxTE\nx0rXv7z/jC0EQDWm/+zAGmaP14EvXoobl8C7BeBgIojxO27TojbRLz+Z8FF8g3Pi\n4daCw1ZTVZwEAnl3brXN9Cj7PLvUFj3pVabMNVMGhtYu74nVK7VxUkT4MtIWEfRD\nVjlDvPra+FkYTFcx0G7gyeS5NEHrxHt8d75LjWJYDxTz/f6f5lrCzgjQX0DAyZ0j\nFpQW93D5AgMBAAECggEAEtuU7hlQySw1Hua/ISLu1Zyd5zrcigv9Z+uInR2RJCKt\nf/wuUsMJGqcjyCTJKgHmex2fsL2l+eTH/4O9rcv/K3bdlRjyyYilRIeLz3YPD76t\ngOqxxwJHHCYlB9SI5vU779PC7t1GhYbokNPTn9kum3NdEcTAcnCcJN0b42qMqeW/\nxadRNYK5/zYGfSPGnPeyW1Al0tX65Ze31Gfn33xokyuGtqS/t7zIuouDyvpJ1R87\nyMfMq2PHC23sKr3fII0CBd5HOHog0CgklYFuQaiuFhS6QNeq8e/S2a5uXIYpkzxl\n36t0jKRCddxHxC7oI4ZHpAFQxDaqFNXshFfqRjhDNwKBgQDqKy3DCjHk8gemV8Qj\nh7+1MUXLWDF7dTvvCJz1U5//5pr24TyOXhQPmfeTJeljA1r+v7ccfKhJ04Jw/weM\nESB04FGnP12budeakId3SA7JOcK5R4oJ/q78Thvvi70xHBbboi1QM6/d7QcZ36/Y\nanlEH/IuL1tIL6l1MyJyEhczhwKBgQDPHNpZLByUtvVSb08UfAD8N/Uurho0ITHX\nI8f1hCBzbAnSZUqBYTAXgOmZIUbWANIhAQT3PbyezdnGHDl23zbZFpKnitOhmXfL\niSunlsAoTKEJxKLWVFHIiLNpKUjpjYkf1xljPSI/NXSUgA8c3yJxN4MTh6DQB3Y9\noMi5zf5XfwKBgQDjQE4j1tP+/IdB/jDBzm7Ut+Gk6ozy5B3q5u/0AVjoLnK7HnD3\nNQPA9EnYitVJGquHSKS6x5tGMjaH1GgNnV1jL4LujUcZ5qv/Oz3MG6kFzcFUr8Gd\n24UUI/VmbrWHYFwqf+P7zn1hITNf/74Wh5Xx8BLGkXzDvEV3EM3f6ACOJwKBgQCk\n0BkRjQDRdyaRivIrIuLF0uHRW8qOYTwAMAEXZyVLtFW8j85SVrymd3ds3AY6ljyg\n9ua0uPQ4iycZd6xi5A4JguUBXoA6wJ2L4oRSwKv5ZcFgvJG4bTEHm4Dp1minMnJE\nXC9fwW5XTnqPEbj1CLunzL0J9YwK/2UgdapF8Z7MkQKBgQCZEs2do/SOu8SiEpau\n9v+DIjEMYmxNwF1Ir8a70CdEq9u7a+QI6WNewRCZ8QoLZARzcJ+TwiACylsQ7AVG\nKBXwERu+vhC7HTHmTvSP3iA0mzcb35ytduzks/xYKG+zMiNPjvb3ND+wquym95c8\nifuspIl0mWAS7FD7Q8HrTGcSFA==\n-----END PRIVATE KEY-----\n",
        "client_email": "clintexai@clintexai-459908.iam.gserviceaccount.com",
        "client_id": "114894698913217053184",
        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
        "token_uri": "https://oauth2.googleapis.com/token",
        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
        "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/clintexai%40clintexai-459908.iam.gserviceaccount.com",
        "universe_domain": "googleapis.com"
    }
    json.dump(credentials, f)

# Set environment variable for the Google Cloud credentials
os.environ['/content/drive/MyDrive/clintexai_vissionapi/new.json'] = CREDENTIALS_PATH

# Load medicine dataset
print("Loading medicine dataset...")
try:
    df_medicines = pd.read_csv(EXPANDED_DRUG_DATASET)
    print(f"✅ Successfully loaded medicine dataset with {len(df_medicines)} records")
    # Display sample data
    print("\nSample Medicine Data:")
    print(df_medicines.head(3))
except Exception as e:
    print(f"❌ Error loading medicine dataset: {e}")
    # Create dataset directory if not exists
    os.makedirs('/content/drive/MyDrive/clintex_dataset', exist_ok=True)


    print("Downloading example medicine dataset...")



    df = pd.read_csv('/content/A_Z_medicines_dataset_of_India.csv')
    # Basic dataset cleaning
    df['medicine_name'] = df['name'].str.lower()
    df['short_composition1'] = df['short_composition1'].str.lower()
    df['pack_size_label'] = df['pack_size_label'].astype(str).str.lower()
    df['manufacturer_name'] = df['manufacturer_name'].astype(str).str.lower()
    df['type'] = df['type'].astype(str).str.lower()

    if 'price(竄ｹ)' in df.columns:
        df.rename(columns={'price(竄ｹ)': 'price(₹)'}, inplace=True)


    df = df.drop_duplicates(subset=['medicine_name', 'short_composition1', 'pack_size_label', 'manufacturer_name', 'type'])

    # Clean unwanted special characters
    def clean_text(text):
        if isinstance(text, str):
            text = re.sub(r'[^a-zA-Z0-9\s\.-₹]', '', text)
            text = re.sub(r'\s+', ' ', text).strip()
        return text

    for col in ['medicine_name', 'short_composition1', 'pack_size_label', 'manufacturer_name', 'type']:
        df[col] = df[col].apply(clean_text)

     # Normalize dosages inside 'short_composition1'
    def normalize_dosage(dosage):
        if isinstance(dosage, str):
            dosage = dosage.lower()
            dosage = dosage.replace('mg', ' mg')
            dosage = dosage.replace('ml', ' ml')
            dosage = dosage.replace('mcg', ' mcg')
            dosage = re.sub(r'\s+', ' ', dosage).strip()
        return dosage

    df['short_composition1'] = df['short_composition1'].apply(normalize_dosage)

    # Save the cleaned expanded dataset
    df_medicines = df[['medicine_name', 'short_composition1', 'pack_size_label', 'manufacturer_name', 'type', 'price(₹)']]
    df_medicines.to_csv(EXPANDED_DRUG_DATASET, index=False)
    print(f"Created and saved cleaned medicine dataset with {len(df_medicines)} records")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import re
from collections import Counter
import plotly.express as px
import os


plt.style.use('fivethirtyeight')
sns.set_palette("Set2")

DATASET_PATH = '/content/drive/MyDrive/clintex_dataset/dataset/A_Z_medicines_dataset_of_India.csv'

if os.path.exists(DATASET_PATH):  # Check if the dataset file exists
    df = pd.read_csv(DATASET_PATH)
else:
    print(f"Error: Dataset file not found at {DATASET_PATH}")


    exit()


price_col = [col for col in df.columns if 'price' in col.lower()][0]
if df[price_col].dtype == 'object':
    df[price_col] = pd.to_numeric(df[price_col].astype(str).str.replace('[^\d.]', '', regex=True), errors='coerce')

print(f"Dataset loaded: {len(df)} records with {len(df.columns)} columns")


# Basic statistics
print("\n--- BASIC STATISTICS ---")
print(f"Missing values: {df.isnull().sum().sum()}")
print(f"Duplicates: {df.duplicated().sum()}")
print(f"\nPrice statistics (₹):")
print(df[price_col].describe().round(2))




if 'manufacturer_name' in df.columns:
    plt.figure(figsize=(12, 7))
    manufacturers = df['manufacturer_name'].value_counts().head(10)
    sns.barplot(y=manufacturers.index, x=manufacturers.values)
    plt.title('Top 10 Manufacturers')
    plt.xlabel('Number of Medicines')
    plt.ylabel('Manufacturer')
    plt.tight_layout()
    plt.show()


plt.figure(figsize=(12, 5))

q1, q3 = df[price_col].quantile(0.01), df[price_col].quantile(0.95)
df_filtered = df[(df[price_col] >= q1) & (df[price_col] <= q3)]
sns.histplot(df_filtered[price_col], bins=30, kde=True)
plt.title('Price Distribution (without extreme outliers)')
plt.xlabel('Price (₹)')
plt.ylabel('Frequency')
plt.tight_layout()
plt.show()


price_ranges = [0, 50, 100, 200, 500, 1000, float('inf')]
price_labels = ['₹0-50', '₹51-100', '₹101-200', '₹201-500', '₹501-1000', '₹1000+']
df['price_range'] = pd.cut(df[price_col], bins=price_ranges, labels=price_labels)
plt.figure(figsize=(10, 6))
price_counts = df['price_range'].value_counts().sort_index()
sns.barplot(x=price_counts.index, y=price_counts.values)
plt.title('Medicines by Price Range')
plt.xlabel('Price Range')
plt.ylabel('Number of Medicines')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

if 'pack_size_label' in df.columns:
    # Extract common pack types
    def extract_pack_type(pack_label):
        if pd.isna(pack_label) or not isinstance(pack_label, str):
            return 'unknown'
        text = pack_label.lower()
        if 'tablet' in text:
            return 'tablets'
        elif 'capsule' in text:
            return 'capsules'
        elif 'syrup' in text:
            return 'syrup'
        elif 'bottle' in text:
            return 'bottle'
        elif 'injection' in text:
            return 'injection'
        else:
            return 'other'

    df['pack_type'] = df['pack_size_label'].apply(extract_pack_type)
    plt.figure(figsize=(10, 6))
    pack_counts = df['pack_type'].value_counts()
    sns.barplot(y=pack_counts.index, x=pack_counts.values)
    plt.title('Distribution of Medicine Pack Types')
    plt.xlabel('Count')
    plt.ylabel('Pack Type')
    plt.tight_layout()
    plt.show()


if 'short_composition1' in df.columns:
    # Extract ingredients
    def extract_ingredients(composition):
        if pd.isna(composition) or not isinstance(composition, str):
            return []
        ingredients = re.findall(r'([a-z\s-]+)\s*\(', composition.lower())
        return [ing.strip() for ing in ingredients]

    # Count ingredients per medicine
    df['ingredient_count'] = df['short_composition1'].fillna('').apply(
        lambda x: len(re.findall(r'([a-z\s-]+)\s*\(', x)) if isinstance(x, str) else 0
    )

    # Plot ingredient count
    plt.figure(figsize=(10, 6))
    sns.countplot(x=df['ingredient_count'])
    plt.title('Number of Ingredients per Medicine')
    plt.xlabel('Number of Ingredients')
    plt.ylabel('Number of Medicines')
    plt.tight_layout()
    plt.show()

    # Single vs. Combination drugs
    single = (df['ingredient_count'] == 1).sum()
    combo = (df['ingredient_count'] > 1).sum()
    plt.figure(figsize=(8, 8))
    plt.pie([single, combo], labels=['Single-ingredient', 'Combination'],
            autopct='%1.1f%%', startangle=90, colors=['#66b3ff', '#ff9999'])
    plt.title('Single-ingredient vs. Combination Medicines')
    plt.axis('equal')
    plt.tight_layout()
    plt.show()

if 'type' in df.columns:
    q1, q3 = df[price_col].quantile(0.01), df[price_col].quantile(0.95)
    df_vis = df[(df[price_col] >= q1) & (df[price_col] <= q3)]
    fig = px.box(df_vis, x='type', y=price_col, title='Price Distribution by Medicine Type',
                 labels={price_col: 'Price (₹)', 'type': 'Medicine Type'},
                 color='type')
    fig.update_layout(height=500, width=800)
    fig.show()

if 'ingredient_count' in df.columns:

    price_by_complexity = df.groupby('ingredient_count')[price_col].agg(['mean', 'median']).reset_index()
    plt.figure(figsize=(10, 6))
    sns.barplot(x='ingredient_count', y='mean', data=price_by_complexity)
    plt.title('Average Price by Number of Ingredients')
    plt.xlabel('Number of Ingredients')
    plt.ylabel('Average Price (₹)')
    plt.tight_layout()
    plt.show()

if 'medicine_name' in df.columns:
    most_expensive = df.nlargest(5, price_col)[['medicine_name', price_col]]
    print("\n--- 5 Most Expensive Medicines ---")
    print(most_expensive)

print("\n--- SUMMARY STATISTICS ---")
print(f"Total medicines: {len(df)}")
if 'type' in df.columns:
    print(f"Most common type: {df['type'].value_counts().index[0]}")
if 'manufacturer_name' in df.columns:
    print(f"Leading manufacturer: {df['manufacturer_name'].value_counts().index[0]}")
if 'ingredient_count' in df.columns:
    print(f"Average ingredients per medicine: {df['ingredient_count'].mean():.2f}")
    print(f"Single-ingredient medicines: {single} ({(single/len(df))*100:.1f}%)")
    print(f"Combination medicines: {combo} ({(combo/len(df))*100:.1f}%)")
print(f"Average price: ₹{df[price_col].mean():.2f}")

print("Initializing OCR tools...")

vision_client = vision.ImageAnnotatorClient()


reader = easyocr.Reader(['en'])

class MedicineRecognitionSystem:
    def __init__(self, medicines_df):
        """Initialize the medicine recognition system with the medicines database"""
        self.medicines_df = medicines_df

    def extract_text_with_google_vision(self, image_path):
        """Extract text from an image using Google Vision API"""
        try:
            # Read the image file
            with io.open(image_path, 'rb') as image_file:
                content = image_file.read()

            # Create an image object
            image = vision.Image(content=content)

            # Perform text detection
            response = vision_client.text_detection(image=image)
            texts = response.text_annotations

            if not texts:
                print("No text detected by Google Vision")
                return ""

            # The first text contains all the detected text
            extracted_text = texts[0].description

            # Process extracted text
            extracted_text = extracted_text.lower()
            extracted_text = re.sub(r'\s+', ' ', extracted_text).strip()

            if response.error.message:
                print(f"Google Vision API Error: {response.error.message}")
                return ""

            return extracted_text
        except Exception as e:
            print(f"Error with Google Vision: {e}")
            return ""

def extract_text_with_backup_methods(self, image_path):
        """Extract text using backup methods (EasyOCR and PyTesseract)"""
        extracted_text = ""


        try:
            result = reader.readtext(image_path, detail=0)
            extracted_text = ' '.join(result)
        except Exception as e:
            print(f"EasyOCR failed: {e}")

        if not extracted_text:
            try:
                img = Image.open(image_path).convert('RGB')
                backup_text = pytesseract.image_to_string(img)
                extracted_text = backup_text
            except Exception as e:
                print(f"PyTesseract failed: {e}")

        return extracted_text.lower()

class MedicineRecognitionSystem:
    def __init__(self, medicines_df):
        self.medicines_df = medicines_df
def extract_text_from_image(self, image_path):
        """Extract text from image with Google Vision as primary and fallback to other methods"""

        extracted_text = self.extract_text_with_google_vision(image_path)

        if not extracted_text:
            print("Falling back to backup OCR methods...")
            extracted_text = self.extract_text_with_backup_methods(image_path)

        if extracted_text:
            extracted_text = extracted_text.lower()
            extracted_text = re.sub(r'[^a-zA-Z0-9\s\.\-,/]', '', extracted_text)  # Clean special characters
            extracted_text = re.sub(r'\s+', ' ', extracted_text).strip()

        return extracted_text

def extract_medicine_keywords(self, text):
        """Extract potential medicine keywords from the text"""

        medicine_indicators = ['tablet', 'capsule', 'syrup', 'suspension', 'injection',
                            'mg', 'ml', 'mcg', 'dose', 'take', 'times', 'daily', 'once',
                            'twice', 'after', 'before', 'meals', 'morning', 'night']


        lines = text.split('\n')
        words = text.split()

        medicine_candidates = []


        for line in lines:
            line = line.strip()
            if any(indicator in line.lower() for indicator in medicine_indicators) and len(line) > 5:

                words = line.split()
                if len(words) >= 2:
                    potential_med = ' '.join(words[:2])
                    medicine_candidates.append(potential_med)


                medicine_candidates.append(line)


        words = text.split()
        for i, word in enumerate(words):
            if len(word) > 3:
                medicine_candidates.append(word)


                if i < len(words) - 1:
                    medicine_candidates.append(f"{word} {words[i+1]}")

                if i < len(words) - 2:
                    medicine_candidates.append(f"{word} {words[i+1]} {words[i+2]}")

        return medicine_candidates

def extract_medicine_names(self, text):
        """Extract potential medicine names from prescription text"""

        medicine_indicators = ['tablet', 'capsule', 'syrup', 'suspension', 'injection',
                              'mg', 'ml', 'mcg', 'tab', 'cap', 'oral', 'take', 'dose']


        medicine_candidates = []


        lines = text.split('\n')

        # Process each line for potential medicine names
        for line in lines:
            line = line.strip().lower()

            # Skip empty lines
            if not line:
                continue

            # If line has medicine indicators, extract potential medicine name
            if any(indicator in line for indicator in medicine_indicators):
                # Try to extract the medicine name (typically first part of the instruction)
                words = line.split()

                # Extract potential medicine names:
                # 1. First word might be the medicine
                if len(words) > 0:
                    medicine_candidates.append(words[0])

                # 2. First two words might be the medicine name
                if len(words) > 1:
                    medicine_candidates.append(f"{words[0]} {words[1]}")

                # 3. First three words might be the medicine name
                if len(words) > 2:
                    medicine_candidates.append(f"{words[0]} {words[1]} {words[2]}")

                # 4. Add the whole line as a candidate
                medicine_candidates.append(line)

        # Also use pattern matching to find potential medicine names
        # Look for capitalized words or words followed by mg/ml
        dosage_pattern = re.compile(r'([a-zA-Z\s]+)\s+\d+\s*(mg|ml|g|mcg)', re.IGNORECASE)
        matches = dosage_pattern.findall(text)
        for match in matches:
            med_name = match[0].strip()
            if len(med_name) > 2:  # Only consider names longer than 2 characters
                medicine_candidates.append(med_name)

        # Remove duplicates and very short candidates
        clean_candidates = []
        for candidate in medicine_candidates:
            candidate = candidate.strip()
            if len(candidate) > 3 and candidate not in clean_candidates:
                clean_candidates.append(candidate)

        return clean_candidates

def extract_entities(self, text):
        """Extract structured entities from prescription text"""
        name = None
        doctor_name = None
        medicines = []
        date = None

        # Extract Date (if available)
        date_patterns = [
            r'\b(\d{1,2}[/-]\d{1,2}[/-]\d{2,4})\b',  # DD/MM/YYYY, MM/DD/YYYY
            r'\b(\d{1,2}\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})\b',  # DD Month YYYY
        ]

        for pattern in date_patterns:
            date_match = re.search(pattern, text, re.IGNORECASE)
            if date_match:
                date = date_match.group(1)
                break

        # Extract Doctor Name (if line starts with Dr. or Doctor)
        doctor_match = re.search(r'(?:dr\.?|doctor)\s+([a-z ]+)', text, re.IGNORECASE)
        if doctor_match:
            doctor_name = doctor_match.group(1).strip().title()

        # Extract Patient Name (simple assumption, line starting with Name or Patient Name)
        name_match = re.search(r'(?:patient name|name|pt\.?|patient)\s*[:\-]?\s*([a-z ]+)', text, re.IGNORECASE)
        if name_match:
            name = name_match.group(1).strip().title()

        # Extract medicines (lines containing mg or ml)
        medicine_lines = []
        for line in text.split('\n'):
            line = line.strip()
            if len(line) > 0 and re.search(r'\b(mg|ml|mcg|tablet|cap)\b', line.lower()):
                medicine_lines.append(line)

        medicines = '; '.join(medicine_lines)

        return {
            'patient_name': name,
            'date': date,
            'doctor_name': doctor_name,
            'medicines': medicines
        }

def suggest_medicines(self, extracted_text, suggestions_per_med=5, max_total_suggestions=20):
        """
        Suggest medicines using RapidFuzz based on extracted OCR text.
        Returns up to `suggestions_per_med` matches per medicine term,
        capped at `max_total_suggestions` in total.
        """
        # Step 1: Extract medicine-like lines (with 'mg', 'ml', etc.)
        medicine_candidates = self.extract_medicine_names(extracted_text)

        # Step 2: Prepare data
        all_medicine_names = self.medicines_df['medicine_name'].dropna().astype(str).tolist()
        all_suggestions = []
        seen_medicines = set()
        print(f"🔍 Medicine candidates from text: {medicine_candidates}")

        # Step 3: Process each candidate term
        for candidate in medicine_candidates:
            matches = rapidfuzz_process.extract(candidate, all_medicine_names, scorer=fuzz.token_set_ratio, limit=suggestions_per_med)

            for medicine_name, score, _ in matches:
                if score >= 65 and medicine_name not in seen_medicines:
                    match_row = self.medicines_df[self.medicines_df['medicine_name'] == medicine_name]
                    if not match_row.empty:
                        info = match_row.iloc[0].to_dict()
                        info['match_score'] = f"{score:.1f}%"
                        info['matched_candidate'] = candidate
                        info['type'] = info.get('type', 'unknown')  # Include tag (e.g., antibiotic, analgesic)
                        all_suggestions.append(info)
                        seen_medicines.add(medicine_name)
                if len(all_suggestions) >= max_total_suggestions:
                    break
            if len(all_suggestions) >= max_total_suggestions:
                break

        # Step 4: Sort by match score
        all_suggestions.sort(key=lambda x: float(x['match_score'].replace('%', '')), reverse=True)
        return all_suggestions

def create_pdf_report(self, prescription_data, suggestions, output_path):
        """Create a nice PDF report with prescription data and medicine suggestions"""
        doc = SimpleDocTemplate(output_path, pagesize=letter)
        styles = getSampleStyleSheet()

        # Create custom styles
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=18,
            textColor=colors.darkblue,
            spaceAfter=12
        )

        subtitle_style = ParagraphStyle(
            'CustomSubTitle',
            parent=styles['Heading2'],
            fontSize=14,
            textColor=colors.darkblue,
            spaceAfter=8
        )

        normal_style = styles['Normal']

        # Header and Footer
        def header_footer(canvas, doc):
            canvas.saveState()
            # Header
            canvas.setFont('Helvetica-Bold', 24)
            canvas.setFillColor(colors.darkblue)
            canvas.drawString(72, 780, "ClintexAI")
            canvas.setFont('Helvetica', 12)
            canvas.setFillColor(colors.black)
            canvas.drawString(72, 765, "Prescription Analysis Report")

            # Footer
            canvas.setFont('Helvetica-Italic', 9)
            canvas.drawString(72, 30, "Generated by ClintexAI")
            canvas.drawString(72, 20, "This medicine suggestion is for reference only. Please consult with a healthcare professional.")
            canvas.restoreState()

        # Content
        elements = []
# Prescription Details Section
        elements.append(Paragraph("Prescription Analysis", title_style))
        elements.append(Spacer(1, 10))
# Prescription Data Table
        prescription_data_list = [
            ["Patient", prescription_data.get('patient_name', 'Not detected')],
            ["Date", prescription_data.get('date', 'Not detected')],
            ["Doctor", prescription_data.get('doctor_name', 'Not detected')]
        ]

        prescription_table = Table(prescription_data_list, colWidths=[100, 350])
        prescription_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),
            ('TEXTCOLOR', (0, 0), (0, -1), colors.darkblue),
            ('ALIGN', (0, 0), (0, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
        ]))
        elements.append(prescription_table)
        elements.append(Spacer(1, 15))

        # Medicines Section
        elements.append(Paragraph("Medicine Suggestions", subtitle_style))
        elements.append(Spacer(1, 10))

        # Create medicine suggestions table
        if suggestions:
            med_table_data = [["Medicine Name", "Composition", "Type", "Manufacturer", "Price (₹)", "Match"]]

            for med in suggestions:
                med_table_data.append([
                    med.get('medicine_name', 'N/A'),
                    med.get('short_composition1', 'N/A'),
                    med.get('type', 'N/A'),
                    med.get('manufacturer_name', 'N/A'),
                    med.get('price(₹)', 'N/A'),
                    med.get('match_score', 'N/A')
                ])

            med_table = Table(med_table_data, colWidths=[80, 120, 70, 100, 60, 50])
            med_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.darkblue),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ]))
            elements.append(med_table)
        else:
            elements.append(Paragraph("No medicine suggestions available", normal_style))

        # Notes section
        elements.append(Spacer(1, 20))
        elements.append(Paragraph("Notes:", subtitle_style))
        elements.append(Paragraph("• Medicine suggestions are based on text extraction from the prescription image.", normal_style))
        elements.append(Paragraph("• The system uses Google Vision API for text recognition and fuzzy matching for medicine identification.", normal_style))
        elements.append(Paragraph("• Always verify the suggestions with a healthcare professional or pharmacist.", normal_style))

        # Build PDF document
        doc.build(elements, onFirstPage=header_footer, onLaterPages=header_footer)
        print(f"✅ PDF report saved at {output_path}")

def process_prescription(self, image_path, output_report_path=None):
    # if caller didn’t supply a path, create a temporary one
    if output_report_path is None:
        import tempfile
        tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
        output_report_path = tmp.name
        tmp.close()

        """Process a prescription image and return suggestions with PDF report"""
        # 1. Extract text from image
        print("Extracting text from prescription...")
        extracted_text = self.extract_text_from_image(image_path)
        print(f"Extracted text length: {len(extracted_text)} characters")
        print(f"Extracted text sample: {extracted_text[:200]}...")
        print("🧾 Extracted Text:\n", extracted_text)

        if not extracted_text:
            print("❌ No text could be extracted from the image")
            return None, None, "No text could be extracted from the image"

        # 2. Extract structured data from text
        print("Extracting structured data...")
        prescription_data = self.extract_entities(extracted_text)

        # 3. Suggest medicines based on extracted text
        print("Suggesting medicines...")
        suggestions = self.suggest_medicines(extracted_text, suggestions_per_med=5, max_total_suggestions=20)
        print(f"Generated {len(suggestions)} medicine suggestions")

        # 4. Generate PDF report if path provided
        if output_pdf_path and suggestions:
            print("Generating PDF report...")
            self.create_pdf_report(prescription_data, suggestions, output_pdf_path)

        return extracted_text, prescription_data, suggestions

import os, traceback, tempfile

def analyze_prescription(image_path, medicine_system):
    """Analyze prescription image and return HTML + link to PDF."""
    try:
        print(f"📸 Image path received: {image_path}")

        if not image_path or not os.path.isfile(image_path):
            return "❌ No valid image received. Please upload a clear prescription image."

        # call the method (it now returns TWO things)
        extracted_data, suggestions = medicine_system.process_prescription(image_path)

        # short HTML response (expand as you like)
        patient = extracted_data.get('patient_name') or "N/A"
        doctor  = extracted_data.get('doctor_name') or "N/A"
        date    = extracted_data.get('date') or "N/A"

        html = f"""
        <h3>✅ Prescription analysed</h3>
        <p><b>Patient:</b> {patient}<br>
           <b>Doctor:</b> {doctor}<br>
           <b>Date:</b> {date}</p>
        <p>Detected medicines: {', '.join(suggestions.keys()) or 'None'}</p>
        <p>PDF report generated alongside the notebook (temporary file if no path was given).</p>
        """
        return html

    except Exception as e:
        traceback.print_exc()
        return f"<pre>❌ Exception occurred:\n{traceback.format_exc()}</pre>"

import os
import re
from google.cloud import vision
import easyocr
import pytesseract
from rapidfuzz import process, fuzz
!pip install fpdf
from fpdf import FPDF
from datetime import datetime

class MedicineRecognitionSystem:
    def __init__(self, df_medicines):
        """
        Initialize the system with a dataframe of medicines.
        df_medicines: pandas DataFrame containing a column of medicine names.
        """
        self.df_medicines = df_medicines
        # Determine medicine names list from DataFrame (assuming 'name' column or first column)
        if 'name' in df_medicines.columns:
            self.medicine_names = df_medicines['name'].astype(str).tolist()
        else:
            self.medicine_names = df_medicines.iloc[:, 0].astype(str).tolist()

    def extract_text_with_google_vision(self, image_path):
        """
        Extract text from image using Google Vision API.
        Returns the full extracted text or None on failure.
        """
        try:
            client = vision.ImageAnnotatorClient()
            with open(image_path, "rb") as image_file:
                content = image_file.read()
            image = vision.Image(content=content)
            response = client.text_detection(image=image)
            if response.error.message:
                return None
            texts = response.text_annotations
            if texts:
                return texts[0].description
        except Exception:
            return None
        return None

    def extract_text_with_backup_methods(self, image_path):
        """
        Use EasyOCR and PyTesseract as backup methods to extract text.
        Returns combined text from available methods.
        """
        extracted_text = ""

        # Try EasyOCR
        try:
            reader = easyocr.Reader(['en'], gpu=False)
            results = reader.readtext(image_path, detail=0)
            if results:
                extracted_text += " ".join(results) + " "
        except Exception:
            pass

        # Try PyTesseract
        try:
            from PIL import Image
            image = Image.open(image_path)
            text_tesseract = pytesseract.image_to_string(image)
            if text_tesseract:
                extracted_text += text_tesseract
        except Exception:
            pass

        return extracted_text.strip()

    def extract_text_from_image(self, image_path):
        """
        Extract text from image, trying Google Vision first, then fallback OCR methods.
        """
        text = self.extract_text_with_google_vision(image_path)
        if text:
            return text
        return self.extract_text_with_backup_methods(image_path)

    def extract_entities(self, text):
        """
        Extract entities such as patient name, doctor name, and date from text.
        Returns a dictionary with keys: patient_name, doctor_name, date.
        """
        data = {'patient_name': None, 'doctor_name': None, 'date': None}
        lines = text.splitlines()

        for line in lines:
            # Date (formats like dd/mm/yyyy or dd-mm-yyyy)
            if data['date'] is None:
                date_match = re.search(r'\b\d{1,2}[/-]\d{1,2}[/-]\d{2,4}\b', line)
                if date_match:
                    data['date'] = date_match.group(0)

            # Doctor name (look for "Dr.")
            if data['doctor_name'] is None:
                doc_match = re.search(r'(Dr\.?\s*[A-Za-z\.]+\s*[A-Za-z\.]*)', line)
                if doc_match:
                    data['doctor_name'] = doc_match.group(0).strip()

            # Patient name (keywords like 'Patient', 'Name')
            if data['patient_name'] is None:
                pat_match = re.search(
                    r'(?:Patient\s*Name|Patient|Name)[:\-]*\s*([A-Za-z][A-Za-z ]+)',
                    line, re.IGNORECASE
                )
                if pat_match:
                    data['patient_name'] = pat_match.group(1).strip()

        # If still no patient name found, guess from first non-empty non-doctor line
        if data['patient_name'] is None:
            for line in lines:
                if line.strip() and 'Dr' not in line and not re.search(r'\d', line):
                    data['patient_name'] = line.strip()
                    break

        return data

    def extract_medicine_names(self, text):
        """
        Extract medicine names from text by matching against known medicine names.
        Returns a list of extracted medicine names.
        """
        extracted_meds = []
        for med in self.medicine_names:
            pattern = r'\b' + re.escape(med) + r'\b'
            if re.search(pattern, text, flags=re.IGNORECASE):
                extracted_meds.append(med)
        return extracted_meds

    def suggest_medicines(self, extracted_medicines):
        """
        Suggest similar medicine names using fuzzy matching for each extracted medicine.
        Returns a dict: {extracted_med: [(suggested_med, score), ...], ...}.
        """
        suggestions = {}
        for med in extracted_medicines:
            matches = process.extract(
                med, self.medicine_names,
                scorer=fuzz.token_sort_ratio,
                limit=5
            )
            suggestions[med] = [(m[0], m[1]) for m in matches]
        return suggestions

    def create_pdf_report(self, extracted_data, suggestions, output_path):
        """
        Generate a PDF report summarizing extracted info and medicine suggestions.
        """
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", 'B', 16)
        pdf.cell(0, 10, "Prescription Report", ln=True, align='C')
        pdf.ln(10)

        pdf.set_font("Arial", size=12)
        patient = extracted_data.get('patient_name') or "N/A"
        doctor  = extracted_data.get('doctor_name') or "N/A"
        date    = extracted_data.get('date') or datetime.now().strftime("%d/%m/%Y")

        pdf.cell(0, 10, f"Patient Name: {patient}", ln=True)
        pdf.cell(0, 10, f"Doctor Name: {doctor}", ln=True)
        pdf.cell(0, 10, f"Date: {date}", ln=True)
        pdf.ln(10)

        pdf.set_font("Arial", 'B', 14)
        pdf.cell(0, 10, "Medicine Suggestions:", ln=True)
        pdf.set_font("Arial", size=12)

        if suggestions:
            for med, sug_list in suggestions.items():
                pdf.cell(0, 10, f"- {med}", ln=True)
                for name, score in sug_list:
                    pdf.cell(0, 10, f"    * {name} (score: {score})", ln=True)
                pdf.ln(5)
        else:
            pdf.cell(0, 10, "No medicine suggestions available.", ln=True)

        pdf.output(output_path)

def process_prescription(self, image_path, output_report_path=None):
    # ← Put this code right at the start of the method body
    if output_report_path is None:
        import tempfile
        tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
        output_report_path = tmp.name
        tmp.close()

    # Now continue with the rest of your existing code:
    text = self.extract_text_from_image(image_path)
    if not text:
        raise ValueError("No text could be extracted from the image.")

    extracted_data = self.extract_entities(text)
    extracted_meds = self.extract_medicine_names(text)
    suggestions = self.suggest_medicines(extracted_meds)
    self.create_pdf_report(extracted_data, suggestions, output_report_path)
    return extracted_data, suggestions

import os
import re
from google.cloud import vision
import easyocr
import pytesseract
from rapidfuzz import process, fuzz
!pip install fpdf
from fpdf import FPDF
from datetime import datetime

class MedicineRecognitionSystem:
    def __init__(self, df_medicines):
        """
        Initialize the system with a dataframe of medicines.
        df_medicines: pandas DataFrame containing a column of medicine names.
        """
        self.df_medicines = df_medicines
        # Determine medicine names list from DataFrame (assuming 'name' column or first column)
        if 'name' in df_medicines.columns:
            self.medicine_names = df_medicines['name'].astype(str).tolist()
        else:
            self.medicine_names = df_medicines.iloc[:, 0].astype(str).tolist()

    # ... (other methods remain the same) ...

    def process_prescription(self, image_path, output_report_path=None):
        # if caller didn’t supply a path, create a temporary one
        if output_report_path is None:
            import tempfile
            tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
            output_report_path = tmp.name
            tmp.close()

        # Now continue with the rest of your existing code:
        text = self.extract_text_from_image(image_path)
        if not text:
            raise ValueError("No text could be extracted from the image.")

        extracted_data = self.extract_entities(text)
        extracted_meds = self.extract_medicine_names(text)
        suggestions = self.suggest_medicines(extracted_meds)
        self.create_pdf_report(extracted_data, suggestions, output_report_path)
        return extracted_data, suggestions

!pip install gradio

# Create Gradio Interface
import gradio as gr

def setup_gradio_interface(medicine_system):
    """Set up and launch the Gradio interface for ClintexAI."""

    # Define the interface
    with gr.Blocks(title="ClintexAI - Prescription Analysis", theme=gr.themes.Base()) as interface:
        gr.Markdown("""
        # 🏥 ClintexAI - Prescription Analysis System

        Upload a prescription image to extract medicines and suggest matches from our database.
        """)

        with gr.Row():
            with gr.Column(scale=1):
                # Input components
                input_image = gr.Image(
                    type="filepath",
                    label="Upload Prescription Image"
                )
                analyze_btn = gr.Button("Analyze Prescription", variant="primary")

                gr.Markdown("""
                ### How It Works
                1. Upload a clear image of a prescription
                2. Click "Analyze Prescription"
                3. View extracted information and medicine suggestions
                4. Download the PDF report (if available)

                *Note: This system is for educational purposes only. Always consult a healthcare professional.*
                """)

            with gr.Column(scale=2):
                # Output components
                output_html = gr.HTML(label="Analysis Results")

                analyze_btn.click(
              fn=lambda img: analyze_prescription(img, medicine_system),
              inputs=[input_image],
              outputs=[output_html]
              )


    return interface

# Main application function
def main():
    """Main application entry point"""
    print("🏥 ClintexAI - Prescription Analysis System")
    print("-------------------------------------------")

    # Initialize medicine recognition system
    print("Initializing Medicine Recognition System...")
    try:
        medicine_system = MedicineRecognitionSystem(df_medicines)
        print("✅ System initialized successfully")
    except Exception as e:
        print(f"❌ Error initializing system: {e}")
        return

    # Setup and launch Gradio interface
    print("Setting up web interface...")
    app = setup_gradio_interface(medicine_system)

    # Launch the interface
    print("🚀 Launching web interface...")
    app.launch(share=True, inbrowser=True)

# Execute main function when script is run directly
if __name__ == "__main__":
    main()

# -*- coding: utf-8 -*-
"""
ClintexAI - Complete Prescription Analysis System
A comprehensive system for analyzing prescription images and suggesting medicines
"""

# Install required libraries
import subprocess
import sys

def install_packages():
    """Install required packages"""
    packages = [
        'opencv-python', 'pillow', 'scikit-image', 'pytesseract', 'openpyxl',
        'easyocr', 'fuzzywuzzy', 'python-Levenshtein', 'reportlab', 'Flask',
        'google-cloud-vision', 'pandas', 'matplotlib', 'rapidfuzz', 'fpdf', 'gradio'
    ]

    for package in packages:
        try:
            subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--quiet', package])
        except subprocess.CalledProcessError:
            print(f"Warning: Could not install {package}")

# Uncomment the following line to install packages
# install_packages()

import os
import re
import cv2
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import io
import json
from datetime import datetime
import tempfile
import traceback

# OCR Libraries
try:
    from google.cloud import vision
    GOOGLE_VISION_AVAILABLE = True
except ImportError:
    GOOGLE_VISION_AVAILABLE = False
    print("Google Vision API not available")

try:
    import easyocr
    EASYOCR_AVAILABLE = True
except ImportError:
    EASYOCR_AVAILABLE = False
    print("EasyOCR not available")

try:
    import pytesseract
    PYTESSERACT_AVAILABLE = True
except ImportError:
    PYTESSERACT_AVAILABLE = False
    print("PyTesseract not available")

# Fuzzy matching
try:
    from rapidfuzz import process as rapidfuzz_process, fuzz
    RAPIDFUZZ_AVAILABLE = True
except ImportError:
    try:
        from fuzzywuzzy import process, fuzz
        RAPIDFUZZ_AVAILABLE = False
    except ImportError:
        print("No fuzzy matching library available")

# PDF generation
try:
    from fpdf import FPDF
    FPDF_AVAILABLE = True
except ImportError:
    try:
        from reportlab.lib.pagesizes import letter
        from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib import colors
        REPORTLAB_AVAILABLE = True
        FPDF_AVAILABLE = False
    except ImportError:
        FPDF_AVAILABLE = False
        REPORTLAB_AVAILABLE = False
        print("No PDF generation library available")

# Gradio for web interface
try:
    import gradio as gr
    GRADIO_AVAILABLE = True
except ImportError:
    GRADIO_AVAILABLE = False
    print("Gradio not available")


class MedicineRecognitionSystem:
    """Complete Medicine Recognition System for prescription analysis"""

    def __init__(self, medicines_df):
        """Initialize the medicine recognition system with the medicines database"""
        self.medicines_df = medicines_df

        # Prepare medicine names list
        if 'medicine_name' in medicines_df.columns:
            self.medicine_names = medicines_df['medicine_name'].dropna().astype(str).tolist()
        elif 'name' in medicines_df.columns:
            self.medicine_names = medicines_df['name'].dropna().astype(str).tolist()
        else:
            self.medicine_names = medicines_df.iloc[:, 0].dropna().astype(str).tolist()

        # Initialize OCR tools
        self.vision_client = None
        self.easyocr_reader = None

        if GOOGLE_VISION_AVAILABLE:
            try:
                self.vision_client = vision.ImageAnnotatorClient()
                print("✅ Google Vision API initialized")
            except Exception as e:
                print(f"❌ Google Vision API initialization failed: {e}")

        if EASYOCR_AVAILABLE:
            try:
                self.easyocr_reader = easyocr.Reader(['en'], gpu=False)
                print("✅ EasyOCR initialized")
            except Exception as e:
                print(f"❌ EasyOCR initialization failed: {e}")

    def extract_text_with_google_vision(self, image_path):
        """Extract text from an image using Google Vision API"""
        if not self.vision_client:
            return ""

        try:
            with io.open(image_path, 'rb') as image_file:
                content = image_file.read()

            image = vision.Image(content=content)
            response = self.vision_client.text_detection(image=image)
            texts = response.text_annotations

            if not texts:
                return ""

            extracted_text = texts[0].description

            if response.error.message:
                print(f"Google Vision API Error: {response.error.message}")
                return ""

            return extracted_text
        except Exception as e:
            print(f"Error with Google Vision: {e}")
            return ""

    def extract_text_with_backup_methods(self, image_path):
        """Extract text using backup methods (EasyOCR and PyTesseract)"""
        extracted_text = ""

        # Try EasyOCR first
        if self.easyocr_reader:
            try:
                result = self.easyocr_reader.readtext(image_path, detail=0)
                extracted_text = ' '.join(result)
            except Exception as e:
                print(f"EasyOCR failed: {e}")

        # If EasyOCR failed or produced empty text, try PyTesseract
        if not extracted_text and PYTESSERACT_AVAILABLE:
            try:
                img = Image.open(image_path).convert('RGB')
                backup_text = pytesseract.image_to_string(img)
                extracted_text = backup_text
            except Exception as e:
                print(f"PyTesseract failed: {e}")

        return extracted_text.lower()

    def extract_text_from_image(self, image_path):
        """Extract text from image with Google Vision as primary and fallback to other methods"""
        # First try Google Vision API
        extracted_text = self.extract_text_with_google_vision(image_path)

        # If Google Vision API failed, try backup methods
        if not extracted_text:
            print("Falling back to backup OCR methods...")
            extracted_text = self.extract_text_with_backup_methods(image_path)

        # Clean the extracted text
        if extracted_text:
            extracted_text = extracted_text.lower()
            extracted_text = re.sub(r'[^a-zA-Z0-9\s\.\-,/]', '', extracted_text)
            extracted_text = re.sub(r'\s+', ' ', extracted_text).strip()

        return extracted_text

    def extract_entities(self, text):
        """Extract structured entities from prescription text"""
        data = {
            'patient_name': None,
            'doctor_name': None,
            'date': None,
            'medicines': []
        }

        lines = text.split('\n')

        for line in lines:
            line = line.strip()

            # Extract Date
            if data['date'] is None:
                date_patterns = [
                    r'\b(\d{1,2}[/-]\d{1,2}[/-]\d{2,4})\b',
                    r'\b(\d{1,2}\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})\b'
                ]
                for pattern in date_patterns:
                    date_match = re.search(pattern, line, re.IGNORECASE)
                    if date_match:
                        data['date'] = date_match.group(1)
                        break

            # Extract Doctor Name
            if data['doctor_name'] is None:
                doctor_match = re.search(r'(?:dr\.?|doctor)\s+([a-z ]+)', line, re.IGNORECASE)
                if doctor_match:
                    data['doctor_name'] = doctor_match.group(1).strip().title()

            # Extract Patient Name
            if data['patient_name'] is None:
                name_match = re.search(r'(?:patient name|name|pt\.?|patient)\s*[:\-]?\s*([a-z ]+)', line, re.IGNORECASE)
                if name_match:
                    data['patient_name'] = name_match.group(1).strip().title()

        # Extract medicine lines
        medicine_lines = []
        for line in text.split('\n'):
            line = line.strip()
            if len(line) > 0 and re.search(r'\b(mg|ml|mcg|tablet|cap)\b', line.lower()):
                medicine_lines.append(line)

        data['medicines'] = medicine_lines

        return data

    def extract_medicine_names(self, text):
        """Extract potential medicine names from prescription text"""
        medicine_indicators = ['tablet', 'capsule', 'syrup', 'suspension', 'injection',
                              'mg', 'ml', 'mcg', 'tab', 'cap', 'oral', 'take', 'dose']

        medicine_candidates = []
        lines = text.split('\n')

        for line in lines:
            line = line.strip().lower()

            if not line:
                continue

            if any(indicator in line for indicator in medicine_indicators):
                words = line.split()

                if len(words) > 0:
                    medicine_candidates.append(words[0])

                if len(words) > 1:
                    medicine_candidates.append(f"{words[0]} {words[1]}")

                if len(words) > 2:
                    medicine_candidates.append(f"{words[0]} {words[1]} {words[2]}")

                medicine_candidates.append(line)

        # Pattern matching for medicine names
        dosage_pattern = re.compile(r'([a-zA-Z\s]+)\s+\d+\s*(mg|ml|g|mcg)', re.IGNORECASE)
        matches = dosage_pattern.findall(text)
        for match in matches:
            med_name = match[0].strip()
            if len(med_name) > 2:
                medicine_candidates.append(med_name)

        # Clean candidates
        clean_candidates = []
        for candidate in medicine_candidates:
            candidate = candidate.strip()
            if len(candidate) > 3 and candidate not in clean_candidates:
                clean_candidates.append(candidate)

        return clean_candidates

    def suggest_medicines(self, extracted_text, suggestions_per_med=5, max_total_suggestions=20):
        """Suggest medicines using fuzzy matching based on extracted OCR text"""
        medicine_candidates = self.extract_medicine_names(extracted_text)
        all_suggestions = []
        seen_medicines = set()

        print(f"🔍 Medicine candidates from text: {medicine_candidates}")

        for candidate in medicine_candidates:
            if RAPIDFUZZ_AVAILABLE:
                matches = rapidfuzz_process.extract(candidate, self.medicine_names,
                                                  scorer=fuzz.token_set_ratio, limit=suggestions_per_med)
            else:
                matches = process.extract(candidate, self.medicine_names, limit=suggestions_per_med)

            for match in matches:
                if RAPIDFUZZ_AVAILABLE:
                    medicine_name, score, _ = match
                else:
                    medicine_name, score = match

                if score >= 65 and medicine_name not in seen_medicines:
                    match_row = self.medicines_df[self.medicines_df.iloc[:, 0] == medicine_name]
                    if not match_row.empty:
                        info = match_row.iloc[0].to_dict()
                        info['match_score'] = f"{score:.1f}%"
                        info['matched_candidate'] = candidate
                        all_suggestions.append(info)
                        seen_medicines.add(medicine_name)

                if len(all_suggestions) >= max_total_suggestions:
                    break

            if len(all_suggestions) >= max_total_suggestions:
                break

        # Sort by match score
        all_suggestions.sort(key=lambda x: float(x['match_score'].replace('%', '')), reverse=True)
        return all_suggestions

    def create_pdf_report(self, prescription_data, suggestions, output_path):
        """Create a PDF report with prescription data and medicine suggestions"""
        if not FPDF_AVAILABLE:
            print("❌ PDF generation not available")
            return

        try:
            pdf = FPDF()
            pdf.add_page()
            pdf.set_font("Arial", 'B', 16)
            pdf.cell(0, 10, "ClintexAI - Prescription Analysis Report", ln=True, align='C')
            pdf.ln(10)

            # Prescription details
            pdf.set_font("Arial", 'B', 14)
            pdf.cell(0, 10, "Prescription Details:", ln=True)
            pdf.set_font("Arial", size=12)

            patient = prescription_data.get('patient_name') or "Not detected"
            doctor = prescription_data.get('doctor_name') or "Not detected"
            date = prescription_data.get('date') or datetime.now().strftime("%d/%m/%Y")

            pdf.cell(0, 10, f"Patient Name: {patient}", ln=True)
            pdf.cell(0, 10, f"Doctor Name: {doctor}", ln=True)
            pdf.cell(0, 10, f"Date: {date}", ln=True)
            pdf.ln(10)

            # Medicine suggestions
            pdf.set_font("Arial", 'B', 14)
            pdf.cell(0, 10, "Medicine Suggestions:", ln=True)
            pdf.set_font("Arial", size=10)

            if suggestions:
                for i, med in enumerate(suggestions[:10]):  # Limit to top 10
                    medicine_name = str(med.get('medicine_name', med.get('name', 'N/A')))
                    match_score = med.get('match_score', 'N/A')

                    pdf.cell(0, 8, f"{i+1}. {medicine_name} (Match: {match_score})", ln=True)

                    composition = str(med.get('short_composition1', med.get('composition', 'N/A')))
                    if len(composition) > 80:
                        composition = composition[:80] + "..."
                    pdf.cell(0, 6, f"    Composition: {composition}", ln=True)
                    pdf.ln(2)
            else:
                pdf.cell(0, 10, "No medicine suggestions available.", ln=True)

            # Footer
            pdf.ln(10)
            pdf.set_font("Arial", 'I', 8)
            pdf.cell(0, 10, "Note: This analysis is for reference only. Please consult a healthcare professional.", ln=True)
            pdf.cell(0, 10, f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", ln=True)

            pdf.output(output_path)
            print(f"✅ PDF report saved at {output_path}")

        except Exception as e:
            print(f"❌ Error creating PDF report: {e}")

    def process_prescription(self, image_path, output_report_path=None):
        """Process a prescription image and return suggestions with PDF report"""
        # Create temporary PDF path if not provided
        if output_report_path is None:
            tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
            output_report_path = tmp.name
            tmp.close()

        try:
            # Extract text from image
            print("Extracting text from prescription...")
            extracted_text = self.extract_text_from_image(image_path)
            print(f"Extracted text length: {len(extracted_text)} characters")

            if not extracted_text:
                raise ValueError("No text could be extracted from the image")

            # Extract structured data from text
            print("Extracting structured data...")
            prescription_data = self.extract_entities(extracted_text)

            # Suggest medicines based on extracted text
            print("Suggesting medicines...")
            suggestions = self.suggest_medicines(extracted_text, suggestions_per_med=5, max_total_suggestions=20)
            print(f"Generated {len(suggestions)} medicine suggestions")

            # Generate PDF report
            if suggestions:
                print("Generating PDF report...")
                self.create_pdf_report(prescription_data, suggestions, output_report_path)

            return prescription_data, suggestions

        except Exception as e:
            print(f"❌ Error processing prescription: {e}")
            traceback.print_exc()
            raise


def analyze_prescription(image_path, medicine_system):
    """Analyze prescription image and return HTML results"""
    try:
        print(f"📸 Image path received: {image_path}")

        if not image_path or not os.path.isfile(image_path):
            return "❌ No valid image received. Please upload a clear prescription image."

        # Process the prescription
        extracted_data, suggestions = medicine_system.process_prescription(image_path)

        # Create HTML response
        patient = extracted_data.get('patient_name') or "Not detected"
        doctor = extracted_data.get('doctor_name') or "Not detected"
        date = extracted_data.get('date') or "Not detected"

        html = f"""
        <div style="font-family: Arial, sans-serif; padding: 20px; border: 1px solid #ddd; border-radius: 10px;">
            <h2 style="color: #2c3e50; text-align: center;">✅ Prescription Analysis Complete</h2>

            <div style="background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
                <h3 style="color: #34495e;">📋 Extracted Information:</h3>
                <p><strong>Patient:</strong> {patient}</p>
                <p><strong>Doctor:</strong> {doctor}</p>
                <p><strong>Date:</strong> {date}</p>
            </div>

            <div style="background-color: #e8f5e8; padding: 15px; border-radius: 5px; margin: 10px 0;">
                <h3 style="color: #27ae60;">💊 Medicine Suggestions ({len(suggestions)} found):</h3>
        """

        if suggestions:
            for i, med in enumerate(suggestions[:5]):  # Show top 5
                medicine_name = med.get('medicine_name', med.get('name', 'N/A'))
                match_score = med.get('match_score', 'N/A')
                composition = med.get('short_composition1', med.get('composition', 'N/A'))

                html += f"""
                <div style="margin: 10px 0; padding: 10px; background-color: white; border-left: 4px solid #3498db;">
                    <strong>{i+1}. {medicine_name}</strong> <span style="color: #e74c3c;">({match_score})</span><br>
                    <small style="color: #7f8c8d;">Composition: {composition}</small>
                </div>
                """
        else:
            html += "<p>No medicine suggestions found.</p>"

        html += """
            </div>

            <div style="background-color: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                <p style="margin: 0; color: #856404;">
                    <strong>⚠️ Disclaimer:</strong> This analysis is for reference only.
                    Always consult with a healthcare professional before taking any medication.
                </p>
            </div>
        </div>
        """

        return html

    except Exception as e:
        traceback.print_exc()
        return f"""
        <div style="color: red; padding: 20px; border: 1px solid red; border-radius: 5px;">
            <h3>❌ Error occurred during analysis:</h3>
            <pre>{str(e)}</pre>
        </div>
        """


def setup_gradio_interface(medicine_system):
    """Set up and launch the Gradio interface for ClintexAI"""
    if not GRADIO_AVAILABLE:
        print("❌ Gradio not available. Cannot create web interface.")
        return None

    with gr.Blocks(title="ClintexAI - Prescription Analysis", theme=gr.themes.Soft()) as interface:
        gr.Markdown("""
        # 🏥 ClintexAI - Prescription Analysis System

        Upload a prescription image to extract medicines and get suggestions from our database.

        **Features:**
        - 🔍 Advanced OCR text extraction (Google Vision API + fallback methods)
        - 💊 Smart medicine matching with fuzzy search
        - 📄 Automated PDF report generation
        - 🎯 High accuracy medicine identification
        """)

        with gr.Row():
            with gr.Column(scale=1):
                input_image = gr.Image(
                    type="filepath",
                    label="📸 Upload Prescription Image",
                    height=300
                )

                analyze_btn = gr.Button(
                    "🔍 Analyze Prescription",
                    variant="primary",
                    size="lg"
                )

                gr.Markdown("""
                ### 📋 Instructions:
                1. **Upload** a clear image of the prescription
                2. **Click** "Analyze Prescription" button
                3. **Review** extracted information and medicine suggestions
                4. **Download** the generated PDF report

                ### 📌 Tips for Best Results:
                - Use good lighting and avoid shadows
                - Ensure text is clearly visible
                - Take image straight-on (avoid angles)
                - Higher resolution images work better

                ---

                *⚠️ **Medical Disclaimer:** This system is for educational and reference purposes only.
                Always consult qualified healthcare professionals for medical advice.*
                """)

            with gr.Column(scale=2):
                output_html = gr.HTML(
                    label="📊 Analysis Results",
                    value="<p style='text-align: center; color: #7f8c8d; font-style: italic;'>Upload an image and click 'Analyze Prescription' to see results here.</p>"
                )

        # Connect the button to the analysis function
        analyze_btn.click(
            fn=lambda img: analyze_prescription(img, medicine_system),
            inputs=[input_image],
            outputs=[output_html]
        )

        gr.Markdown("""
        ---

        ### 🔧 System Information:
        - **OCR Engine:** Google Vision API (primary) + EasyOCR + PyTesseract (fallback)
        - **Matching Algorithm:** RapidFuzz with token-based similarity scoring
        - **Database:** Comprehensive Indian medicines dataset
        - **Report Format:** PDF with detailed analysis

        **Developed by ClintexAI Team** | *Prescription Analysis Made Simple*
        """)

    return interface


def create_sample_medicine_dataset():
    """Create a sample medicine dataset for testing purposes"""
    sample_data = {
        'medicine_name': [
            'paracetamol', 'ibuprofen', 'aspirin', 'amoxicillin', 'azithromycin',
            'metformin', 'atorvastatin', 'amlodipine', 'losartan', 'omeprazole',
            'cetirizine', 'ranitidine', 'domperidone', 'dolo 650', 'crocin',
            'combiflam', 'augmentin', 'azee', 'pan d', 'limcee'
        ],
        'short_composition1': [
            'paracetamol 500mg', 'ibuprofen 400mg', 'aspirin 75mg', 'amoxicillin 500mg', 'azithromycin 500mg',
            'metformin 500mg', 'atorvastatin 10mg', 'amlodipine 5mg', 'losartan 50mg', 'omeprazole 20mg',
            'cetirizine 10mg', 'ranitidine 150mg', 'domperidone 10mg', 'paracetamol 650mg', 'paracetamol 500mg',
            'ibuprofen 400mg + paracetamol 325mg', 'amoxicillin 500mg + clavulanic acid 125mg', 'azithromycin 500mg',
            'pantoprazole 40mg + domperidone 10mg', 'vitamin c 500mg'
        ],
        'type': [
            'analgesic', 'analgesic', 'analgesic', 'antibiotic', 'antibiotic',
            'antidiabetic', 'statin', 'antihypertensive', 'antihypertensive', 'ppi',
            'antihistamine', 'antacid', 'prokinetic', 'analgesic', 'analgesic',
            'analgesic', 'antibiotic', 'antibiotic', 'ppi', 'vitamin'
        ],
        'manufacturer_name': [
            'generic', 'generic', 'generic', 'generic', 'generic',
            'generic', 'generic', 'generic', 'generic', 'generic',
            'generic', 'generic', 'generic', 'micro labs', 'gsk',
            'sanofi', 'gsk', 'alkem', 'aristo', 'abbott'
        ],
        'price(₹)': [
            10, 15, 5, 50, 80, 25, 100, 30, 40, 35,
            20, 25, 30, 25, 20, 30, 120, 90, 45, 60
        ]
    }

    return pd.DataFrame(sample_data)


def main():
    """Main application entry point"""
    print("🏥 ClintexAI - Prescription Analysis System")
    print("=" * 50)

    # Load or create medicine dataset
    print("📊 Loading medicine dataset...")
    try:
        # Try to load from the specified path first
        EXPANDED_DRUG_DATASET = '/content/drive/MyDrive/clintex_dataset/dataset/A_Z_medicines_dataset_of_India.csv'
        if os.path.exists(EXPANDED_DRUG_DATASET):
            df_medicines = pd.read_csv(EXPANDED_DRUG_DATASET)
            print(f"✅ Loaded medicine dataset with {len(df_medicines)} records")
        else:
            # Create sample dataset for testing
            print("📝 Creating sample medicine dataset...")
            df_medicines = create_sample_medicine_dataset()
            print(f"✅ Created sample dataset with {len(df_medicines)} records")
    except Exception as e:
        print(f"❌ Error loading dataset: {e}")
        print("📝 Creating sample medicine dataset...")
        df_medicines = create_sample_medicine_dataset()

    # Initialize medicine recognition system
    print("🔧 Initializing Medicine Recognition System...")
    try:
        medicine_system = MedicineRecognitionSystem(df_medicines)
        print("✅ System initialized successfully")

        # Display system capabilities
        print("\n🔍 Available OCR Methods:")
        print(f"  - Google Vision API: {'✅' if GOOGLE_VISION_AVAILABLE else '❌'}")
        print(f"  - EasyOCR: {'✅' if EASYOCR_AVAILABLE else '❌'}")
        print(f"  - PyTesseract: {'✅' if PYTESSERACT_AVAILABLE else '❌'}")

        print(f"\n📊 Fuzzy Matching: {'✅ RapidFuzz' if RAPIDFUZZ_AVAILABLE else '✅ FuzzyWuzzy'}")
        print(f"📄 PDF Generation: {'✅' if FPDF_AVAILABLE else '❌'}")

    except Exception as e:
        print(f"❌ Error initializing system: {e}")
        return

    # Setup and launch Gradio interface
    if GRADIO_AVAILABLE:
        print("\n🌐 Setting up web interface...")
        app = setup_gradio_interface(medicine_system)

        if app:
            print("🚀 Launching web interface...")
            app.launch(
                share=True,
                inbrowser=True,
                server_name="0.0.0.0",
                server_port=7860
            )
        else:
            print("❌ Failed to create web interface")
    else:
        print("❌ Gradio not available. Web interface cannot be launched.")
        print("💡 You can still use the medicine_system object directly for analysis.")


# Execute main function when script is run directly
if __name__ == "__main__":
    main()